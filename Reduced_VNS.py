# -*- coding: utf-8 -*-
"""Reduced_VNS(1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l_UkxffNJUCc8-s8pmKNMq20Hrl2UTgB
"""

#Importing Libraries
import numpy as np
import pandas as pd
import random
import itertools
import collections
import time

#Importing data
data = pd.ExcelFile('Soft_Computing_Data.xlsx')

#Importing tables individually
CAB_10_nodes_flow = pd.read_excel(data, '10_nodes_CAB_flow', header = None)  
CAB_10_nodes_cost = pd.read_excel(data, '10_nodes_CAB_cost', header = None)  
CAB_25_nodes_flow = pd.read_excel(data, '25_nodes_CAB_flow', header = None)    
CAB_25_nodes_cost = pd.read_excel(data, '25_nodes_CAB_cost', header = None)
TR_55_nodes_flow = pd.read_excel(data, '55_nodes_TR_flow', header = None)
TR_55_nodes_cost = pd.read_excel(data, '55_nodes_TR_cost', header = None)  
TR_81_nodes_flow = pd.read_excel(data, '81_nodes_TR_flow', header = None)    
TR_81_nodes_cost = pd.read_excel(data, '81_nodes_TR_cost', header = None)
RGP_100_nodes_flow = pd.read_excel(data, '100_nodes_RGP_flow', header = None)
RGP_100_nodes_cost = pd.read_excel(data, '100_nodes_RGP_cost', header = None)  
RGP_130_nodes_flow = pd.read_excel(data, '130_nodes_RGP_flow', header = None)    
RGP_130_nodes_cost = pd.read_excel(data, '130_nodes_RGP_cost', header = None)

#Generating the initial solution
def least_cost_initial_solution(cost_matrix, number_hubs):
    number_nodes = cost_matrix.shape[0]
    nodes = range(1, number_nodes + 1)
    random.sample(nodes, number_hubs)
    hubs = random.sample(nodes, number_hubs)
    spokes = [node for node in nodes if node not in hubs]
    initial_solution = [0]*number_nodes
    
    for node in nodes:
        if node in hubs:
            initial_solution[node - 1] = node
        else:
            hub_spoke_cost = {hub : cost_matrix[node - 1][hub - 1] for hub in hubs}
            initial_solution[node - 1] = min(hub_spoke_cost, key = hub_spoke_cost.get)
    
    return initial_solution

#Calculating the network cost
def network_cost(initial_solution, flow_matrix, cost_matrix, alpha = 0.2):
    
    number_nodes = cost_matrix.shape[0]
    cost = 0
    flow = 0
    for node_1 in range(number_nodes):
        for node_2 in range(number_nodes):
            cost += flow_matrix[node_1][node_2] * (cost_matrix[node_1][initial_solution[node_1]-1] + 
                    alpha*cost_matrix[initial_solution[node_1] - 1][initial_solution[node_2] - 1] +
                    cost_matrix[initial_solution[node_2]-1][node_2]) 
            flow += flow_matrix[node_1][node_2]        
              
   
    return cost/flow

#Neighbourhood structures
def NS1(array, spoke):
  n_array = array.copy()
  hub = n_array[spoke - 1]
  for i in range(len(n_array)):
    if n_array[i] == hub:
      n_array[i] = spoke
  return n_array

def NS2(array, spoke, hub):
  n_array = array.copy()
  n_array[spoke-1] = hub
  return n_array

def NS3(array, spoke_1, spoke_2):
  n_array = array.copy()
  n_array[spoke_1 - 1], n_array[spoke_2 - 1] = n_array[spoke_2 - 1], n_array[spoke_1 - 1]
  return n_array

def NS4(array, hub_1, hub_2):
  n_array = array.copy()
  spokes = [node for node in range(1, len(n_array) + 1) if node not in n_array]
  spokes_hub_1 = [spoke for spoke in spokes if n_array[spoke - 1] == hub_1]
  spokes_hub_2 = [spoke for spoke in spokes if n_array[spoke - 1] == hub_2]
  for node in spokes_hub_1:
      n_array[node - 1] = hub_2
  for node in spokes_hub_2:
      n_array[node - 1] = hub_1
  return n_array

#Generating random solution from neighbourhood
def LS_NS1_Random(array, w, c, alpha):
  spokes = [i for i in range(1, len(array)+1) if i not in array]
  chosen_spoke = random.choice(spokes)
  neighbour = NS1(array, chosen_spoke)
  neighbour_cost = network_cost(neighbour, w, c, alpha)
  return neighbour, neighbour_cost

def LS_NS2_Random(array, w, c, alpha):
  spokes = [i for i in range(1, len(array)+1) if i not in array]
  chosen_spoke = random.choice(spokes)
  chosen_hub = random.choice(list(set(array)-{array[chosen_spoke-1]}))
  neighbour = NS2(array, chosen_spoke, chosen_hub)
  neighbour_cost = network_cost(neighbour, w, c, alpha)
  return neighbour, neighbour_cost

def LS_NS3_Random(array, w, c, alpha):
  spokes = [i for i in range(1, len(array)+1) if i not in array]
  spoke_1 = random.choice(spokes)
  spoke_2 = random.choice(spokes)
  while array[spoke_1 - 1] == array[spoke_2 - 1]:
    spoke_2 = random.choice(spokes)
  neighbour = NS3(array, spoke_1, spoke_2)
  neighbour_cost = network_cost(neighbour, w, c, alpha)
  return neighbour, neighbour_cost, spoke_1, spoke_2

def LS_NS4_Random(array, w, c, alpha):
  chosen_hubs = random.sample(set(array), 2)
  hub_1 = chosen_hubs[0]
  hub_2 = chosen_hubs[1]
  neighbour = NS4(array, hub_1, hub_2)
  neighbour_cost = network_cost(neighbour, w, c, alpha)
  return neighbour, neighbour_cost

def NB_Search_Random(NS, array, w, c, alpha):
  if NS == 1:
    return LS_NS1_Random(array, w, c, alpha)
  elif NS == 2:
    return LS_NS2_Random(array, w, c, alpha)
  elif NS == 3:
    return LS_NS4_Random(array, w, c, alpha)

#Main alogrithm
def vns(w, c, alpha, p, iter, k_size):
  start = time.time()
  first_solution = least_cost_initial_solution(c, p)
  current_solution = first_solution.copy()
  current_cost = network_cost(first_solution, w, c, alpha)
  for iteration in range(iter):
    k = 1
    while k <= k_size:
      new_solution_set = NB_Search_Random(k, current_solution, w, c, alpha)
      new_solution_cost = new_solution_set[1]
      if new_solution_cost < current_cost:
        current_solution = new_solution_set[0]
        current_cost = new_solution_cost
        k = 1
      else:
        k+=1
    end = time.time()
  return [current_solution, current_cost, end-start]

#Result Generator
def check_solutions(flow_matrix, cost_matrix, alpha, p, iter, k_size):
  cost = []
  comp_time = []
  solutions = []
  for i in range(10):
    result = vns(flow_matrix, cost_matrix, alpha, p, iter, k_size)
    best_candidate = result[0]
    best_cost = result[1]
    timer = result[2]
    solutions.append(best_candidate)
    cost.append(best_cost)
    comp_time.append(timer)
    print(best_candidate)
    print(best_cost)
    print(timer)
    print('\n')
  best_cost = min(cost)
  best_solution = solutions[cost.index(min(cost))]
  print('Best Cost:', best_cost)
  print('Best Network:', best_solution)
  print('Optimum hubs:', set(best_solution))
  print('Average Cost:', sum(cost)/10)
  print('Average Time', sum(comp_time)/10)

#Results
check_solutions(CAB_10_nodes_flow, CAB_10_nodes_cost, 0.2, 3, 120, 3)

check_solutions(CAB_10_nodes_flow, CAB_10_nodes_cost, 0.2, 3, 120)

check_solutions(CAB_10_nodes_flow, CAB_10_nodes_cost, 0.8, 3, 120)

check_solutions(CAB_10_nodes_flow, CAB_10_nodes_cost, 0.2, 5, 120)

check_solutions(CAB_10_nodes_flow, CAB_10_nodes_cost, 0.8, 5, 120)

check_solutions(CAB_25_nodes_flow, CAB_25_nodes_cost, 0.2, 3, 120)

check_solutions(CAB_25_nodes_flow, CAB_25_nodes_cost, 0.8, 3, 120)

check_solutions(CAB_25_nodes_flow, CAB_25_nodes_cost, 0.2, 5, 120)

check_solutions(CAB_25_nodes_flow, CAB_25_nodes_cost, 0.8, 5, 120)

check_solutions(TR_55_nodes_flow, TR_55_nodes_cost, 0.2, 3, 120)

check_solutions(TR_55_nodes_flow, TR_55_nodes_cost, 0.8, 3, 120)

check_solutions(TR_55_nodes_flow, TR_55_nodes_cost, 0.2, 5, 120)

check_solutions(TR_55_nodes_flow, TR_55_nodes_cost, 0.8, 5, 120)

check_solutions(TR_81_nodes_flow, TR_81_nodes_cost, 0.2, 5, 120)

check_solutions(TR_81_nodes_flow, TR_81_nodes_cost, 0.8, 5, 120)

check_solutions(TR_81_nodes_flow, TR_81_nodes_cost, 0.2, 7, 120)

check_solutions(TR_81_nodes_flow, TR_81_nodes_cost, 0.8, 7, 120)

check_solutions(RGP_100_nodes_flow, RGP_100_nodes_cost, 0.2, 7, 120)

check_solutions(RGP_100_nodes_flow, RGP_100_nodes_cost, 0.8, 7, 120)

check_solutions(RGP_100_nodes_flow, RGP_100_nodes_cost, 0.2, 10, 120)

check_solutions(RGP_100_nodes_flow, RGP_100_nodes_cost, 0.8, 10, 120)

check_solutions(RGP_130_nodes_flow, RGP_130_nodes_cost, 0.2, 7, 120)

check_solutions(RGP_130_nodes_flow, RGP_130_nodes_cost, 0.8, 7, 120)

check_solutions(RGP_130_nodes_flow, RGP_130_nodes_cost, 0.2, 10, 120)

check_solutions(RGP_130_nodes_flow, RGP_130_nodes_cost, 0.8, 10, 120)

